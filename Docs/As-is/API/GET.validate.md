# Endpoint `GET /validate`

## Общая информация
**Назначение:** Валидация токена для запросов к защищенным ресурсам системы.

**Метод:** GET

**Внутренний URL:** `http://auth-service:4005/validate`

**Внешний URL:** `http://{gateway-host}/auth/validate`

---

## Входные и выходные параметры
<details>
<summary><span style="color: #2E86C1;"><b>Входные параметры</b></span></summary>
Header:

| Параметр | Тип данных | Обязательность | Описание | Значение/пример | Маппинг с auth_db |
|:------|:-----------|:---------------|:---------|:-----------------|:------------------|
|Authorization|string|да|Bearer <token>| Bearer eyJhbGciOiJIUzI1NiJ9... | - |

</details>

---

## Примеры запроса и ответа

Запрос:
~~~ 
curl -X GET "{host}/validate" \
-H "Authorization: Bearer <token>"
~~~

Ответ:
~~~
Response code : 200 OK
~~~

<details>
<summary><span style="color: #2E86C1;"><b>Варианты возвращаемых HTTP статус кодов</b></span></summary>

| Код | Статус | Сообщение | Описание                                                                                                                                                                                 |
|:---|:---|:---|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 200 | OK | - | Токен валиден. Успешно пройдены проверки структуры, криптографической подписи и срока действия.                                                                                          |
| 401 | UNAUTHORIZED | - | Ошибка заголовка или валидации. Заголовок отсутствует, не содержит префикс "Bearer " или библиотека JJWT выбросила исключение (неверная подпись, истекший срок, поврежденная структура). |
| 500 | INTERNAL SERVER ERR | - | Критическая ошибка. Непредвиденный системный сбой при обработке запроса или ошибка инициализации секретного ключа.                                                                       |

</details>

---

## Алгоритм работы (GET /validate)

1. `auth-service` через `AuthController` получает запрос `GET /validate`.С помощью аннотации `@RequestHeader` извлекается значение заголовка `Authorization`. `AuthController` проверяет наличие и формат заголовка. Если заголовок отсутствует или не начинается с префикса `Bearer ` — сервис возвращает статус-код `401 UNAUTHORIZED`.


2. `AuthController` отсекает префикс `Bearer` (первые 7 символов) и передает полученную «сырую» JWT-строку в метод `validateToken()` `AuthService` для проведения комплексной валидации.


3. `AuthService` С помощью библиотеки `JJWT` выполняются следующие последовательные проверки:

   3.1. **Проверка структуры:** проверяется, что токен состоит из трех частей: `Header`, `Payload`, `Signature`, разделенных точками. Если формат нарушен — сервис идентифицирует ошибку структуры.

   3.2. **Проверка подписи:**  используетcя секретный ключ `Secret Key` (определенный в конфигурации) для верификации подписи. Если вычисленный хеш не совпадает с `Signature` в токене — сервис идентифицирует ошибку подписи.

   3.3. **Проверка срока действия:** из `Payload` извлекается значение клейма `exp`. Сервис сравнивает его с текущим временем сервера. Если время сервера больше — сервис идентифицирует ошибку срока действия.



Если в процессе выполнения (шаг 2) выброшено любое исключение, наследуемое от `JwtException`, `AuthController` перехватывает его и возвращает статус-код `401 UNAUTHORIZED`.

3. При успешном завершении всех проверок в `AuthService`, `AuthController` формирует ответ и возвращает статус-код `200 OK`.


**Системные сбои:**
Если в процессе выполнения метода возникает критический сбой, не связанный с данными токена (например, ошибка конфигурации секретного ключа или нехватка памяти сервера) — **auth-service** возвращает статус-код **500 INTERNAL SERVER ERROR**.
---

![GET.validate.svg](..%2FDiagrams%2FGET.validate.svg)